package javase.object;

/**
 * <p>
 *
 * @author liyazhou1
 * @date 2018/12/13
 */
public class ExtendsDemo {

    /*

    继承的好处：
        1，提高了代码的复用性。
        2，让类与类之间产生了关系，给第三个特征多态提供了前提.


    java中支持单继承。不直接支持多继承，但对C++中的多继承机制进行改良。
    单继承：一个子类只能有一个直接父类。
    多继承：一个子类可以有多个直接父类(java中不允许,进行改良)
            不直接支持，因为多个父类中有相同成员，会产生调用不确定性。
            在java中是通过"多实现"的方式来体现。


    java支持多层(多重)继承。
        C继承B，B继承A。
        就会出现继承体系。


    当要使用一个继承体系时，
        1，查看该体系中的顶层类，了解该体系的基本功能。
        2，创建体系中的最子类对象，完成功能的使用。


    什么时候定义继承呢？
        当类与类之间存在着所属关系的时候，就定义继承。xxx是yyy中的一种。 xxx extends yyy
        所属关系： is a 关系。



    在子父类中，成员的特点体现。
    1，成员变量。
    2，成员函数。
    3，构造函数。

    //1，成员变量。

    当本类的成员和局部变量同名用this区分。
    当子父类中的成员变量同名用super区分父类。
    this和super的用法很相似。
    this:代表一个本类对象的引用。
    super：代表一个父类空间。


    //成员函数。

    当子父类中出现成员函数一模一样的情况，会运行子类的函数。
    这种现象，称为覆盖操作。这时函数在子父类中的特性。
    函数两个特性：
        1，重载。同一个类中。overload
        2，覆盖。子类中。覆盖也称为重写，覆写。override

    覆盖注意事项：
    1，子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限。
    2，静态只能覆盖静态，或被静态覆盖。


    什么时候使用覆盖操作?
    当对一个类进行子类的扩展时，子类需要保留父类的功能声明，
    但是要定义子类中该功能的特有内容时，就使用覆盖操作完成.


    子父类中的构造函数的特点。
    在子类构造对象时，发现，访问子类构造函数时，父类也运行了。

    为什么呢？
    原因是：在子类的构造函数中第一行有一个默认的隐式语句。 super();
    子类的实例化过程：子类中所有的构造函数默认都会访问父类中的空参数的构造函数。


    为什么子类实例化的时候要访问父类中的构造函数呢？
    那是因为子类继承了父类，获取到了父类中内容(属性)，所以在使用父类内容之前，
    要先看父类是如何对自己的内容进行初始化的。
    所以子类在构造对象时，必须访问父类中的构造函数。

    为什么完成这个必须的动作，就在子类的构造函数中加入了super()语句。
    如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用
    父类中哪个构造函数。同时子类构造函数中如果使用this调用了本类构造函数时，
    那么super就没有了，因为super和this都只能定义第一行。所以只能有一个。
    但是可以保证的是，子类中肯定会有其他的构造函数访问父类的构造函数。

    注意：super语句必须要定义在子类构造函数的第一行。因为父类的初始化动作要先完成。



    一个对象实例化过程：
        Person p = new Person();
        1，JVM会读取指定的路径下的Person.class文件，并加载进内存，
            并会先加载Person的父类(如果有直接的父类的情况下).
        2，在堆内存中的开辟空间，分配地址。
        3，并在对象空间中，对对象中的属性进行默认初始化。
        4，调用对应的构造函数进行初始化。
        5，在构造函数中，第一行会先到调用父类中构造函数进行初始化。
        6，父类初始化完毕后，在对子类的属性进行显示初始化。
        7，在进行子类构造函数的特定初始化。
        8，初始化完毕后，将地址值赋值给引用变量.

     */
}
